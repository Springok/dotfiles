set nocursorline " don't highlight current line
set noswapfile

" git commit textwidth limit
autocmd Filetype gitcommit setlocal spell textwidth=72

set langmenu=en_US.UTF-8
language messages en_US.UTF-8

" keyboard shortcuts
nnoremap <silent> <tab> :bn<CR>
nnoremap <silent> <S-tab> :bp<CR>

" in insert mode jj can return to normal mode
inoremap jj <ESC>

" vim tab switch convention
noremap gr gT
noremap! gr gT

" in all modes ,, can return to normal mode
noremap  ,, <C-\><C-N>
noremap!  ,, <C-\><C-N>

" Plugin setting
let g:vim_markdown_folding_disabled=1

" -- override default ignore comment and string in vim-easy-align
let g:easy_align_ignore_groups = []

" -------------------
" vim-easy-align
" -------------------
" Start interactive EasyAlign in visual mode
  vmap <Enter> <Plug>(EasyAlign)
" Start interactive EasyAlign with a Vim movement
" nmap <Leader>a <Plug>(EasyAlign)vmap <Enter> <Plug>(EasyAlign)

" Disambiguate ,a & ,t from the Align plugin, making them fast again.
"
" This section is here to prevent AlignMaps from adding a bunch of mappings
" that interfere with the very-common ,a and ,t mappings. This will get run
" at every startup to remove the AlignMaps for the *next* vim startup.
"
" If you do want the AlignMaps mappings, remove this section, remove
" ~/.vim/bundle/Align, and re-run rake in maximum-awesome.

function! s:RemoveConflictingAlignMaps()
  if exists("g:loaded_AlignMapsPlugin")
    AlignMapsClean
  endif
endfunction
command! -nargs=0 RemoveConflictingAlignMaps call s:RemoveConflictingAlignMaps()
silent! autocmd VimEnter * RemoveConflictingAlignMaps

" GUI settings
if (&t_Co == 256 || has('gui_running'))
  if ($TERM_PROGRAM == 'iTerm.app')
    colorscheme solarized
  else
    colorscheme desert
  endif
endif

set background=dark
colorscheme solarized

" -------------------
" Vim-airline
" -------------------
" Smart tab line
let g:airline#extensions#tabline#enabled = 1
let g:airline_powerline_fonts = 1

if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif

let g:airline_left_sep = '⮀'
let g:airline_left_alt_sep = '⮁'
let g:airline_right_sep = '⮂'
let g:airline_right_alt_sep = '⮃'
let g:airline_symbols.branch = '⭠'
let g:airline_symbols.readonly = '⭤'
let g:airline_symbols.linenr = '⭡'

"然後以下加在 .vimrc，就能辨別 tmux 來的 paste（省得 `set paste`）
"但從 Mac 剪貼來的可能還是沒辦法
" Bracketed Paste Mode
"  Ref http://slashdot.jp/journal/506765/Bracketed-Paste-Mode
"  - Use tmux 1.7 `paste-buffer -p` to paste
"  - Use <F11> and tmux `send-keys "\e[201~"` for pastetoggle

if &term =~ "xterm" && exists('$TMUX')
  let &t_ti = &t_ti . "\e[?2004h"
  let &t_te = "\e[?2004l" . &t_te
  let &pastetoggle = "\e[201~"
  map <F11> <Esc>[201~
  imap <F11> <Esc>[201~

  function! XTermPasteBegin(ret)
    set paste
    return a:ret
  endfunction

  map <special> <expr> <Esc>[200~ XTermPasteBegin("i")
  imap <special> <expr> <Esc>[200~ XTermPasteBegin("")
  cmap <special> <Esc>[200~ <nop>
  cmap <special> <Esc>[201~ <nop>
endif


" https://trello.com/c/pJuYf16V/2-vim-command-shortcut
" test current file use shortcut
if has('vim_starting')
  if executable('w')
    " let result = system("w --no-header --short | wc -l")
    " if str2nr(result) > 1
    if 1
      autocmd User Rails call s:rails_test_helpers_for_pair()

      function! s:rails_test_helpers_for_pair() "{{{
        let type = rails#buffer().type_name()
        let relative = rails#buffer().relative()
        if type =~ '^test' || (type == 'javascript-coffee' && relative =~ '^test/')
          nmap \t [rtest]
          nnoremap <silent> [rtest]l :call <SID>rails_test_tmux('h')<CR>
          nnoremap <silent> [rtest]w :call <SID>rails_test_tmux('new-window')<CR>
          nnoremap <silent> [rtest]. :call <SID>rails_test_tmux('last')<CR>
        end
      endfunction "}}}
    endif
  endif
endif

function! s:rails_test_tmux(method) "{{{
  let [it, path] = ['', '']

  let rails_type = rails#buffer().type_name()
  let rails_relative = rails#buffer().relative()

  if rails_type =~ '^test'
    let it = matchstr(
          \   getline(
          \     search('^\s*it\s\+\(\)', 'bcnW')
          \   ),
          \   'it\s*[''"]\zs.*\ze[''"]'
          \ )
    let path = rails_relative
  elseif rails_type == 'javascript-coffee' && rails_relative =~ '^test/'
    " Currently, teaspoon can't filter specs without 'describe' title
    " https://github.com/modeset/teaspoon/issues/304
    let desc = matchstr(
          \   getline(
          \     search('^\s*describe\s*\(\)', 'bcnW')
          \   ),
          \   'describe\s*[''"]\zs.*\ze[''"]'
          \ )
    let it = matchstr(
          \   getline(
          \     search('^\s*it\s\+\(\)', 'bcnW')
          \   ),
          \   'it\s*[''"]\zs.*\ze[''"]'
          \ )
    let it = (empty(desc) || empty(it)) ?
          \ '' :
          \ join([desc, it], ' ')
    let path = rails_relative
  end

  if empty(it) || empty(path)
    let it   = get(s:, 'rails_test_tmux_last_it', '')
    let path = get(s:, 'rails_test_tmux_last_path', '')
  end

  if empty(it) || empty(path)
    echohl WarningMsg | echomsg 'No `it` block found' | echohl None
    return
  end

  let s:rails_test_tmux_last_it = it
  let s:rails_test_tmux_last_path = path

  if rails_type == 'javascript-coffee'
    " https://github.com/modeset/teaspoon/wiki/Teaspoon-Configuration
    " TODO add back `--filter` if I can handle nested `describe` blocks
    " let test_command = printf('RAILS_RELATIVE_URL_ROOT= teaspoon %s --fail-fast -f pride --filter %s', path, shellescape(it))
    let test_command = printf('FAIL_FAST=true FORMATTERS=documentation rake teaspoon files=%s', path)
    let title = '☕️'
  elseif rails_type == 'test-integration'
    " TODO why can't just use ruby -Itest?
    let test_command = printf('RAILS_RELATIVE_URL_ROOT= bundle exec rake test:integration TEST=%s', path)
    let title = matchstr(rails_type, '\vtest-\zs.{4}')
  else
    let test_command = printf('bundle exec ruby -Itest %s --name /%s/', path, shellescape(escape(it, '()')))
    let type_short = matchstr(rails_type, '\vtest-\zs.{4}')
    if type_short == 'unit'
      let title = type_short
    elseif type_short == 'func'
      let title = type_short
    else
      let title = type_short
    endif
  endif

  call TmuxNewWindow({
        \   "text": test_command,
        \   "title": '∫ ' . title,
        \   "directory": rails#app().root,
        \   "remember_pane": 1,
        \   "method": a:method
        \ })
endfunction "}}}

function! TmuxNewWindow(...) "{{{
  let options = a:0 ? a:1 : {}
  let text = get(options, 'text', '')
  let title = get(options, 'title', '')
  let directory = get(options, 'directory', getcwd())
  let method = get(options, 'method', 'new-window')
  let size = get(options, 'size', '40')
  let remember_pane = get(options, 'remember_pane', 0)
  let pane = ''

  if method == 'last'
    if !exists('s:last_tmux_pane') || empty(s:last_tmux_pane)
      echohl WarningMsg | echomsg "Can't find last tmux pane. Continue with 'new-window'." | echohl None
      let method = 'new-window'
    else
      " if system(printf('tmux list-pane -s -F "#{pane_id}" | egrep %%%s$', s:last_tmux_pane) =~ '%'
      "   let pane = s:last_tmux_pane
      " else
      "   echohl WarningMsg | echomsg "Can't find last tmux pane. Continue with 'new-window'." | echohl None
      "   let method = 'new-window'
      " endif
      let pane = s:last_tmux_pane
    endif
  elseif method == 'quit'
    if !exists('s:last_tmux_pane') || empty(s:last_tmux_pane)
      echohl WarningMsg | echomsg "Can't find last used pane." | echohl None
      return
    else
      call system('tmux kill-pane -t ' . matchstr(s:last_tmux_pane, '%\d\+'))
      unlet! s:last_tmux_pane
      return
    endif
  endif

  if empty(pane) && method != 'new-window'
    " use splitted pane if available
    let pane = matchstr(
          \   system('tmux list-pane -F "#{window_id}#{pane_id}:#{pane_active}" | egrep 0$'),
          \   '\zs@\d\+%\d\+\ze'
          \ )
  endif

  if empty(pane)
    if method == 'new-window'
      let cmd = 'tmux new-window -a '
            \ . (empty(title) ? '' : printf('-n %s', shellescape(title)))
            \ . printf(' -c %s', shellescape(directory))
    elseif method == 'v'
      let cmd = 'tmux split-window -d -v '
            \ . printf('-p %s -c %s ', size, shellescape(directory))
    elseif method == 'h'
      let cmd = 'tmux split-window -d -h '
            \ . printf(' -c %s ', shellescape(directory))
    endif

    let pane = substitute(
          \   system(cmd . ' -P -F "#{window_id}#{pane_id}"'), '\n$', '', ''
          \ )
  endif

  if remember_pane
    let s:last_tmux_pane = pane
  endif

  let window_id = matchstr(pane, '@\d\+')
  let pane_id = matchstr(pane, '%\d\+')

  if !empty(text)
    let cmd = printf(
          \   'tmux set-buffer %s \; paste-buffer -t %s -d \; send-keys -t %s Enter',
          \   shellescape(text),
          \   pane_id,
          \   pane_id
          \ )
    sleep 300m
    call system('tmux select-window -t ' . window_id)
    call system(cmd)
  endif
endfunction "}}}

" run sql file to give your sql result table! ,r + j, l, r
function! s:init_qrpsqlpq()
  nmap <buffer> <Leader>r [qrpsqlpq]
  nnoremap <silent> <buffer> [qrpsqlpq]j :call qrpsqlpq#run('split')<CR>
  nnoremap <silent> <buffer> [qrpsqlpq]l :call qrpsqlpq#run('vsplit')<CR>
  nnoremap <silent> <buffer> [qrpsqlpq]r :call qrpsqlpq#run()<CR>

  if !exists('b:rails_root')
    call RailsDetect()
  endif
  if !exists('b:rails_root')
    let b:qrpsqlpq_db_name = 'postgTes'
  endif
endfunction

if executable('psql')
  let g:qrpsqlpq_expanded_format_max_lines = -1
  autocmd FileType sql call s:init_qrpsqlpq()
endif

set secure
